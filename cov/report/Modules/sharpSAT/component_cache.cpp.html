<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>component_cache.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*
 * component_cache.cpp
 *
 *  Created on: Feb 5, 2013
 *      Author: mthurley
 */

#include &lt;sharpSAT/component_cache.h&gt;
#include &lt;sharpSAT/stack.h&gt;

#include &lt;algorithm&gt;
#include &lt;iostream&gt;

#ifdef __linux__

#include &lt;sys/sysinfo.h&gt;
#include &lt;cstdint&gt;

namespace sharpSAT {
uint64_t freeram() {

  struct sysinfo info;
      sysinfo(&amp;info);

  return info.freeram *(uint64_t) info.mem_unit;
}
} // sharpSAT namespace

#elif __APPLE__ &amp;&amp; __MACH__

#include &lt;sys/types.h&gt;
#include &lt;sys/sysctl.h&gt;


namespace sharpSAT {
uint64_t freeram() {

  int mib[2];
  int64_t physical_memory;
  mib[0] = CTL_HW;
  mib[1] = HW_MEMSIZE;
  size_t length = sizeof(int64_t);
  sysctl(mib, 2, &amp;physical_memory, &amp;length, NULL, 0);

  return physical_memory;
}
} // sharpSAT namespace


#elif _MSC_VER

#include &lt;windows.h&gt;

<span style = "background-color:#dfd">uint64_t freeram() {</span>
    MEMORYSTATUSEX state;
<span style = "background-color:#dfd">    state.dwLength = sizeof(state);
    GlobalMemoryStatusEx(&amp;state);
    return state.ullAvailPhys;
}</span>


#else
// ToDo: Provide something like freeram
#error "freeram function not provided for this platform"

#endif

using namespace std;

namespace sharpSAT {

ComponentCache::ComponentCache(DataAndStatistics &amp;statistics) :
<span style = "background-color:#dfd">		statistics_(statistics) {
}</span>

<span style = "background-color:#dfd">void ComponentCache::init(Component &amp;super_comp, SolverConfiguration &amp;config) {</span>

<span style = "background-color:#dfd">	if (config.verbose) {</span>
<span style = "background-color:#fdd">    	cout &lt;&lt; sizeof(CacheableComponent) &lt;&lt; " " &lt;&lt; sizeof(mpz_class) &lt;&lt; endl;</span>
	}

<span style = "background-color:#dfd">    CacheableComponent &amp;packed_super_comp = *new CacheableComponent(super_comp);
	my_time_ = 1;</span>

<span style = "background-color:#dfd">	entry_base_.clear();
	entry_base_.reserve(2000000);
	entry_base_.push_back(new CacheableComponent()); // dummy Element
	table_.clear();
	table_.resize(1024*1024, 0);
	table_size_mask_ = table_.size() - 1;</span>

<span style = "background-color:#dfd">	free_entry_base_slots_.clear();
	free_entry_base_slots_.reserve(10000);</span>

<span style = "background-color:#dfd">	uint64_t free_ram = freeram();
	uint64_t max_cache_bound = 95 * (free_ram / 100);</span>

<span style = "background-color:#dfd">	if (statistics_.maximum_cache_size_bytes_ == 0) {
	  statistics_.maximum_cache_size_bytes_ = max_cache_bound;</span>
	}

<span style = "background-color:#dfd">	if (statistics_.maximum_cache_size_bytes_ &gt; free_ram) {</span>
<span style = "background-color:#fdd">		if (!config.quiet) {
			cout &lt;&lt; endl &lt;&lt;" WARNING: Maximum cache size larger than free RAM available" &lt;&lt; endl;
			cout &lt;&lt; " Free RAM " &lt;&lt; free_ram / 1000000 &lt;&lt; "MB" &lt;&lt; endl;</span>
		}
	}

<span style = "background-color:#dfd">	if (config.verbose) {</span>
<span style = "background-color:#fdd">		cout &lt;&lt; "Maximum cache size:\t"</span>
			&lt;&lt; statistics_.maximum_cache_size_bytes_ / 1000000 &lt;&lt; " MB" &lt;&lt; endl
			&lt;&lt; endl;
	}

<span style = "background-color:#dfd">	assert(!statistics_.cache_full());</span>

<span style = "background-color:#dfd">	if (entry_base_.capacity() == entry_base_.size())</span>
<span style = "background-color:#fdd">		entry_base_.reserve(2 * entry_base_.size());</span>

<span style = "background-color:#dfd">	entry_base_.push_back(&amp;packed_super_comp);</span>

<span style = "background-color:#dfd">	statistics_.incorporate_cache_store(packed_super_comp);</span>

<span style = "background-color:#dfd">	super_comp.set_id(1);
}</span>

void ComponentCache::test_descendantstree_consistency() {
	for (unsigned id = 2; id &lt; entry_base_.size(); id++)
		if (entry_base_[id] != nullptr) {
			CacheEntryID act_child = entry(id).first_descendant();
			while (act_child) {
				CacheEntryID next_child = entry(act_child).next_sibling();
				assert(entry(act_child).father() == id);

				act_child = next_child;
			}
			CacheEntryID father = entry(id).father();
			CacheEntryID act_sib = entry(father).first_descendant();

			bool found = false;

			while (act_sib) {
				CacheEntryID next_sib = entry(act_sib).next_sibling();
				if (act_sib == id)
					found = true;
				act_sib = next_sib;
			}
			assert(found);
		}
}





<span style = "background-color:#fdd">bool ComponentCache::deleteEntries() {
  assert(statistics_.cache_full());</span>

<span style = "background-color:#fdd">	vector&lt;double&gt; scores;
	for (auto it = entry_base_.begin() + 1; it != entry_base_.end(); it++)
		if (*it != nullptr &amp;&amp; (*it)-&gt;isDeletable()) {
			scores.push_back((double) (*it)-&gt;creation_time());
		}
	sort(scores.begin(), scores.end());
	double cutoff = scores[scores.size() / 2];</span>

	//cout &lt;&lt; "cutoff" &lt;&lt; cutoff  &lt;&lt; " entries: "&lt;&lt; entry_base_.size()&lt;&lt; endl;

	// first : go through the EntryBase and mark the entries to be deleted as deleted (i.e. EMPTY
	// note we start at index 2,
	// since index 1 is the whole formula,
	// should always stay here!
<span style = "background-color:#fdd">	for (unsigned id = 2; id &lt; entry_base_.size(); id++)</span>
		if (entry_base_[id] != nullptr &amp;&amp;
<span style = "background-color:#fdd">		    entry_base_[id]-&gt;isDeletable() &amp;&amp;</span>
		      (double) entry_base_[id]-&gt;creation_time() &lt;= cutoff) {
<span style = "background-color:#fdd">				removeFromDescendantsTree(id);
				eraseEntry(id);</span>

<span style = "background-color:#fdd">        }</span>
	// then go through the Hash Table and erase all Links to empty entries


#ifdef DEBUG
	test_descendantstree_consistency();
#endif

<span style = "background-color:#fdd">	reHashTable(table_.size());
	statistics_.sum_size_cached_components_ = 0;
	statistics_.sum_bytes_cached_components_ = 0;
	 statistics_.sys_overhead_sum_bytes_cached_components_ =0;</span>

<span style = "background-color:#fdd">	statistics_.sum_bytes_pure_cached_component_data_ = 0;</span>

<span style = "background-color:#fdd">	for (unsigned id = 2; id &lt; entry_base_.size(); id++)
		if (entry_base_[id] != nullptr) {
			statistics_.sum_size_cached_components_ +=</span>
					entry_base_[id]-&gt;num_variables();
<span style = "background-color:#fdd">			statistics_.sum_bytes_cached_components_ +=</span>
			    entry_base_[id]-&gt;SizeInBytes();
<span style = "background-color:#fdd">			statistics_.sum_bytes_pure_cached_component_data_ +=</span>
			    entry_base_[id]-&gt;data_only_byte_size();
<span style = "background-color:#fdd">			 statistics_.sys_overhead_sum_bytes_cached_components_ +=</span>
			     entry_base_[id]-&gt;sys_overhead_SizeInBytes();
<span style = "background-color:#fdd">		}</span>

<span style = "background-color:#fdd">	statistics_.num_cached_components_ = entry_base_.size();
	compute_byte_size_infrasture();</span>

	//cout &lt;&lt; " \t entries: "&lt;&lt; entry_base_.size() - free_entry_base_slots_.size()&lt;&lt; endl;
<span style = "background-color:#fdd">	return true;
}</span>


<span style = "background-color:#dfd">uint64_t ComponentCache::compute_byte_size_infrasture() {
  statistics_.cache_infrastructure_bytes_memory_usage_ =</span>
      sizeof(ComponentCache)
      + sizeof(CacheEntryID)* table_.capacity()
      + sizeof(CacheableComponent *)* entry_base_.capacity()
      + sizeof(CacheEntryID) * free_entry_base_slots_.capacity();
<span style = "background-color:#dfd">  return statistics_.cache_infrastructure_bytes_memory_usage_;
}</span>

<span style = "background-color:#fdd">void ComponentCache::debug_dump_data(){
    cout &lt;&lt; "sizeof (CacheableComponent *, CacheEntryID) "</span>
         &lt;&lt; sizeof(CacheableComponent *) &lt;&lt; ", "
         &lt;&lt; sizeof(CacheEntryID) &lt;&lt; endl;
<span style = "background-color:#fdd">    cout &lt;&lt; "table (size/capacity) " &lt;&lt; table_.size()</span>
         &lt;&lt; "/" &lt;&lt; table_.capacity() &lt;&lt; endl;
<span style = "background-color:#fdd">    cout &lt;&lt; "entry_base_ (size/capacity) " &lt;&lt; entry_base_.size()</span>
             &lt;&lt; "/" &lt;&lt; entry_base_.capacity() &lt;&lt; endl;
<span style = "background-color:#fdd">    cout &lt;&lt; "free_entry_base_slots_ (size/capacity) " &lt;&lt; free_entry_base_slots_.size()</span>
             &lt;&lt; "/" &lt;&lt; free_entry_base_slots_.capacity() &lt;&lt; endl;

//    uint64_t size_model_counts = 0;
<span style = "background-color:#fdd">    uint64_t alloc_model_counts = 0;
    for (auto &amp;pentry : entry_base_)
              if (pentry != nullptr){</span>
//                size_model_counts += pentry-&gt;size_of_model_count();
<span style = "background-color:#fdd">                alloc_model_counts += pentry-&gt;alloc_of_model_count();
              }
    cout &lt;&lt; "model counts size " &lt;&lt; alloc_model_counts &lt;&lt; endl;
}</span>
} // sharpSAT namespace</pre>
	</body>
</html>