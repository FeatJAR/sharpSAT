<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>instance.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*
 * instance.cpp
 *
 *  Created on: Aug 23, 2012
 *      Author: Marc Thurley
 */

#include &lt;sharpSAT/instance.h&gt;

#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sys/stat.h&gt;

using namespace std;

namespace sharpSAT {

<span style = "background-color:#dfd">void Instance::cleanClause(ClauseOfs cl_ofs) {
  bool satisfied = false;
  for (auto it = beginOf(cl_ofs); *it != SENTINEL_LIT; it++)
    if (isSatisfied(*it)) {
      satisfied = true;
      break;
    }</span>
  // mark the clause as empty if satisfied
<span style = "background-color:#dfd">  if (satisfied) {
    *beginOf(cl_ofs) = SENTINEL_LIT;
    return;</span>
  }
<span style = "background-color:#dfd">  auto jt = beginOf(cl_ofs);
  auto it = beginOf(cl_ofs);</span>
  // from now, all inactive literals are resolved
<span style = "background-color:#dfd">  for (; *it != SENTINEL_LIT; it++, jt++) {
    while (*jt != SENTINEL_LIT &amp;&amp; !isActive(*jt))
      jt++;
    *it = *jt;
    if (*jt == SENTINEL_LIT)
      break;
  }
  unsigned length = it - beginOf(cl_ofs);</span>
  // if it has become a unit clause, it should have already been asserted
<span style = "background-color:#dfd">  if (length == 1) {</span>
<span style = "background-color:#fdd">    *beginOf(cl_ofs) = SENTINEL_LIT;</span>
    // if it has become binary, transform it to binary and delete it
<span style = "background-color:#dfd">  } else if (length == 2) {
    addBinaryClause(*beginOf(cl_ofs), *(beginOf(cl_ofs) + 1));
    *beginOf(cl_ofs) = SENTINEL_LIT;</span>
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">void Instance::compactClauses() {
  vector&lt;ClauseOfs&gt; clause_ofs;
  clause_ofs.reserve(statistics_.num_long_clauses_);</span>

  // clear watch links and occurrence lists
<span style = "background-color:#dfd">  for (auto it_lit = literal_pool_.begin(); it_lit != literal_pool_.end();
      it_lit++) {
    if (*it_lit == SENTINEL_LIT) {
      if (it_lit + 1 == literal_pool_.end())
        break;
      it_lit += ClauseHeader::overheadInLits();
      clause_ofs.push_back(ClauseOfs(1 + it_lit - literal_pool_.begin()));
    }
  }</span>

<span style = "background-color:#dfd">  for (auto ofs : clause_ofs)
    cleanClause(ofs);</span>

<span style = "background-color:#dfd">  for (auto &amp;l : literals_)
    l.resetWatchList();</span>

<span style = "background-color:#dfd">  occurrence_lists_.clear();
  occurrence_lists_.resize(variables_.size());</span>

<span style = "background-color:#dfd">  vector&lt;LiteralID&gt; tmp_pool = literal_pool_;
  literal_pool_.clear();
  literal_pool_.push_back(SENTINEL_LIT);
  ClauseOfs new_ofs;
  unsigned num_clauses = 0;
  for (auto ofs : clause_ofs) {
    auto it = (tmp_pool.begin() + static_cast&lt;unsigned&gt;(ofs));
    if (*it != SENTINEL_LIT) {
      for (unsigned i = 0; i &lt; ClauseHeader::overheadInLits(); i++)
        literal_pool_.push_back(LiteralID());
      new_ofs = ClauseOfs(literal_pool_.size());
      literal(*it).addWatchLinkTo(new_ofs);
      literal(*(it + 1)).addWatchLinkTo(new_ofs);
      num_clauses++;
      for (; *it != SENTINEL_LIT; it++) {
        literal_pool_.push_back(*it);
        occurrence_lists_[*it].push_back(new_ofs);
      }
      literal_pool_.push_back(SENTINEL_LIT);</span>
    }
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  vector&lt;LiteralID&gt; tmp_bin;
  unsigned bin_links = 0;
  for (auto &amp;l : literals_) {
    tmp_bin.clear();
    for (auto it = l.binary_links_.begin(); *it != SENTINEL_LIT; it++)
      if (isActive(*it))
        tmp_bin.push_back(*it);
    bin_links += tmp_bin.size();
    tmp_bin.push_back(SENTINEL_LIT);
    l.binary_links_ = tmp_bin;
  }
  statistics_.num_long_clauses_ = num_clauses;
  statistics_.num_binary_clauses_ = bin_links &gt;&gt; 1;
}</span>

<span style = "background-color:#dfd">void Instance::compactVariables() {
  VariableIndexedVector&lt;VariableIndex&gt; var_map(variables_.size(), VariableIndex(0));
  VariableIndex last_ofs(0);
  unsigned num_isolated = 0;
  LiteralIndexedVector&lt;vector&lt;LiteralID&gt; &gt; _tmp_bin_links(1);
  LiteralIndexedVector&lt;TriValue&gt; _tmp_values = literal_values_;</span>

<span style = "background-color:#dfd">  for (auto l : literals_)
    _tmp_bin_links.push_back(l.binary_links_);</span>

<span style = "background-color:#dfd">  assert(_tmp_bin_links.size() == literals_.size());
  for (VariableIndex v(1); v &lt; VariableIndex(variables_.size()); ++v)
    if (isActive(LiteralID(v, true))) {
      if (isolated(v)) {
        num_isolated++;
        continue;</span>
      }
<span style = "background-color:#dfd">      ++last_ofs;
      var_map[v] = last_ofs;
    }</span>

<span style = "background-color:#dfd">  variables_.clear();
  variables_.resize(static_cast&lt;unsigned&gt;(last_ofs) + 1);
  occurrence_lists_.clear();
  occurrence_lists_.resize(variables_.size());
  literals_.clear();
  literals_.resize(variables_.size());
  literal_values_.clear();
  literal_values_.resize(variables_.size(), TriValue::X_TRI);</span>

<span style = "background-color:#dfd">  unsigned bin_links = 0;
  LiteralID newlit;
  for (auto l = LiteralID(VariableIndex(0), false); l != _tmp_bin_links.end_lit(); l.inc()) {
    if (var_map[l.var()] != VariableIndex(0)) {
      newlit = LiteralID(var_map[l.var()], l.sign());
      for (auto it = _tmp_bin_links[l].begin(); *it != SENTINEL_LIT; it++) {
        assert(var_map[it-&gt;var()] != VariableIndex(0));
        literals_[newlit].addBinLinkTo(</span>
            LiteralID(var_map[it-&gt;var()], it-&gt;sign()));
<span style = "background-color:#dfd">      }
      bin_links += literals_[newlit].binary_links_.size() - 1;</span>
    }
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  vector&lt;ClauseOfs&gt; clause_ofs;
  clause_ofs.reserve(statistics_.num_long_clauses_);</span>
  // clear watch links and occurrence lists
<span style = "background-color:#dfd">  for (auto it_lit = literal_pool_.begin(); it_lit != literal_pool_.end();
      it_lit++) {
    if (*it_lit == SENTINEL_LIT) {
      if (it_lit + 1 == literal_pool_.end())
        break;
      it_lit += ClauseHeader::overheadInLits();
      clause_ofs.push_back(ClauseOfs(1 + it_lit - literal_pool_.begin()));
    }
  }</span>

<span style = "background-color:#dfd">  for (auto ofs : clause_ofs) {
    literal(LiteralID(var_map[beginOf(ofs)-&gt;var()], beginOf(ofs)-&gt;sign())).addWatchLinkTo(</span>
        ofs);
<span style = "background-color:#dfd">    literal(LiteralID(var_map[(beginOf(ofs) + 1)-&gt;var()],</span>
            (beginOf(ofs) + 1)-&gt;sign())).addWatchLinkTo(ofs);
<span style = "background-color:#dfd">    for (auto it_lit = beginOf(ofs); *it_lit != SENTINEL_LIT; it_lit++) {
      *it_lit = LiteralID(var_map[it_lit-&gt;var()], it_lit-&gt;sign());
      occurrence_lists_[*it_lit].push_back(ofs);
    }
  }</span>

<span style = "background-color:#dfd">  literal_values_.clear();
  literal_values_.resize(variables_.size(), TriValue::X_TRI);
  unit_clauses_.clear();</span>

<span style = "background-color:#dfd">  statistics_.num_variables_ = variables_.size() - 1 + num_isolated;</span>

<span style = "background-color:#dfd">  statistics_.num_used_variables_ = num_variables();
  statistics_.num_free_variables_ = num_isolated;
}</span>

<span style = "background-color:#fdd">void Instance::compactConflictLiteralPool(){
  auto write_pos = conflict_clauses_begin();
  vector&lt;ClauseOfs&gt; tmp_conflict_clauses = conflict_clauses_;
  conflict_clauses_.clear();
  for(auto clause_ofs: tmp_conflict_clauses){
    auto read_pos = beginOf(clause_ofs) - ClauseHeader::overheadInLits();
    for(unsigned i = 0; i &lt; ClauseHeader::overheadInLits(); i++)
      *(write_pos++) = *(read_pos++);
    ClauseOfs new_ofs = ClauseOfs(write_pos - literal_pool_.begin());
    conflict_clauses_.push_back(new_ofs);</span>
    // first substitute antecedent if clause_ofs implied something
<span style = "background-color:#fdd">    if(isAntecedentOf(clause_ofs, *beginOf(clause_ofs)))
      var(*beginOf(clause_ofs)).ante = Antecedent(new_ofs);</span>

    // now redo the watches
<span style = "background-color:#fdd">    literal(*beginOf(clause_ofs)).replaceWatchLinkTo(clause_ofs,new_ofs);
    literal(*(beginOf(clause_ofs)+1)).replaceWatchLinkTo(clause_ofs,new_ofs);</span>
    // next, copy clause data
<span style = "background-color:#fdd">    assert(read_pos == beginOf(clause_ofs));
    while(*read_pos != SENTINEL_LIT)
      *(write_pos++) = *(read_pos++);
    *(write_pos++) = SENTINEL_LIT;
  }
  literal_pool_.erase(write_pos,literal_pool_.end());
}</span>


//bool Instance::deleteConflictClauses() {
//  statistics_.times_conflict_clauses_cleaned_++;
//  vector&lt;ClauseOfs&gt; tmp_conflict_clauses = conflict_clauses_;
//  conflict_clauses_.clear();
//  vector&lt;double&gt; tmp_ratios;
//  double score, lifetime;
//  for(auto clause_ofs: tmp_conflict_clauses){
//    score = getHeaderOf(clause_ofs).score();
//    lifetime = statistics_.num_conflicts_ - getHeaderOf(clause_ofs).creation_time();
//    tmp_ratios.push_back(score/lifetime/(getHeaderOf(clause_ofs).length()));
//  }
//  vector&lt;double&gt; tmp_ratiosB = tmp_ratios;
//
//  sort(tmp_ratiosB.begin(), tmp_ratiosB.end());
//
//  double cutoff = tmp_ratiosB[tmp_ratiosB.size()/2];
//
//  for(unsigned i = 0; i &lt; tmp_conflict_clauses.size(); i++){
//    if(tmp_ratios[i] &lt; cutoff){
//      if(!markClauseDeleted(tmp_conflict_clauses[i]))
//        conflict_clauses_.push_back(tmp_conflict_clauses[i]);
//    } else
//      conflict_clauses_.push_back(tmp_conflict_clauses[i]);
//  }
//  return true;
//}

<span style = "background-color:#dfd">bool Instance::deleteConflictClauses() {
  statistics_.times_conflict_clauses_cleaned_++;
  vector&lt;ClauseOfs&gt; tmp_conflict_clauses = conflict_clauses_;
  conflict_clauses_.clear();
  vector&lt;double&gt; tmp_ratios;</span>
  double score;
<span style = "background-color:#dfd">  for(auto clause_ofs: tmp_conflict_clauses){
    score = getHeaderOf(clause_ofs).score();
    tmp_ratios.push_back(score);</span>

<span style = "background-color:#dfd">  }
  vector&lt;double&gt; tmp_ratiosB = tmp_ratios;</span>

<span style = "background-color:#dfd">  sort(tmp_ratiosB.begin(), tmp_ratiosB.end());</span>

<span style = "background-color:#dfd">  double cutoff = tmp_ratiosB[tmp_ratiosB.size()/2];</span>

<span style = "background-color:#dfd">  for(unsigned i = 0; i &lt; tmp_conflict_clauses.size(); i++){
    if(tmp_ratios[i] &lt; cutoff){</span>
<span style = "background-color:#fdd">      if(!markClauseDeleted(tmp_conflict_clauses[i]))
        conflict_clauses_.push_back(tmp_conflict_clauses[i]);
    } else</span>
<span style = "background-color:#dfd">      conflict_clauses_.push_back(tmp_conflict_clauses[i]);
  }
  return true;
}</span>


<span style = "background-color:#fdd">bool Instance::markClauseDeleted(ClauseOfs cl_ofs){</span>
  // only first literal may possibly have cl_ofs as antecedent
<span style = "background-color:#fdd">  if(isAntecedentOf(cl_ofs, *beginOf(cl_ofs)))
    return false;</span>

<span style = "background-color:#fdd">  literal(*beginOf(cl_ofs)).removeWatchLinkTo(cl_ofs);
  literal(*(beginOf(cl_ofs)+1)).removeWatchLinkTo(cl_ofs);
  return true;
}</span>


void Instance::initialize(
    unsigned int nVars,
    unsigned int nCls,
<span style = "background-color:#dfd">    unsigned int poolSize) {</span>

  // 1) Clear everything
<span style = "background-color:#dfd">  literal_pool_.clear();
  literal_pool_.push_back(SENTINEL_LIT);</span>

<span style = "background-color:#dfd">  variables_.clear();
  variables_.push_back(Variable()); //initializing the Sentinel
  literal_values_.clear();
  unit_clauses_.clear();</span>

  // 2) Allocate correct sizes
<span style = "background-color:#dfd">  variables_.resize(nVars + 1);
  literal_values_.resize(nVars + 1, TriValue::X_TRI);
  literal_pool_.reserve(poolSize);
  conflict_clauses_.reserve(2*nCls);
  occurrence_lists_.clear();
  occurrence_lists_.resize(nVars + 1);</span>

<span style = "background-color:#dfd">  literals_.clear();
  literals_.resize(nVars + 1);
}</span>


<span style = "background-color:#dfd">void Instance::add_clause(std::vector&lt;LiteralID&gt;&amp; literals) {
  assert(!literals.empty());
  statistics_.incorporateClauseData(literals);
  ClauseOfs cl_ofs = addClause(literals);
  if (literals.size() &gt;= 3) {
    assert(static_cast&lt;unsigned&gt;(cl_ofs) &gt; 0);
    for (auto l : literals)
      occurrence_lists_[l].push_back(cl_ofs);</span>
  }
<span style = "background-color:#dfd">}</span>


<span style = "background-color:#dfd">void Instance::finalize(unsigned int nVars, unsigned int nCls) {
  statistics_.num_variables_ = statistics_.num_original_variables_ = nVars;
  statistics_.num_used_variables_ = num_variables();
  statistics_.num_free_variables_ = nVars - num_variables();</span>

<span style = "background-color:#dfd">  statistics_.num_original_clauses_ = nCls;</span>

<span style = "background-color:#dfd">  statistics_.num_original_binary_clauses_ = statistics_.num_binary_clauses_;
  statistics_.num_original_unit_clauses_ = statistics_.num_unit_clauses_ =</span>
      unit_clauses_.size();

<span style = "background-color:#dfd">  original_lit_pool_size_ = literal_pool_.size();
}</span>


<span style = "background-color:#dfd">bool Instance::createfromFile(const string &amp;file_name) {</span>
  unsigned int nVars; // #variables in the file
  unsigned int nCls; // #clauses in the file
<span style = "background-color:#dfd">  unsigned clauses_added = 0; // #clauses added to the instance</span>

  // Start reading the file
<span style = "background-color:#dfd">  ifstream input_file(file_name);
  if (!input_file) {
    cerr &lt;&lt; "Cannot open file: " &lt;&lt; file_name &lt;&lt; endl;
    exit(0);</span>
  }

  char c;
  // fast-forward to the 'p [variables] [clauses]' line
<span style = "background-color:#dfd">  while (input_file &gt;&gt; c &amp;&amp; c != 'p')
    input_file.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');</span>

<span style = "background-color:#dfd">  string idstring;
  if (!(input_file &gt;&gt; idstring &amp;&amp; idstring == "cnf" &amp;&amp; input_file &gt;&gt; nVars</span>
      &amp;&amp; input_file &gt;&gt; nCls)) {
<span style = "background-color:#fdd">    cerr &lt;&lt; "Invalid CNF file" &lt;&lt; endl;
    exit(1);</span>
  }

  // estimate literal count
  struct stat filestatus;
<span style = "background-color:#dfd">  stat(file_name.c_str(), &amp;filestatus);</span>
  // prepare to be filled
<span style = "background-color:#dfd">  initialize(nVars, nCls, filestatus.st_size);</span>


<span style = "background-color:#dfd">  vector&lt;LiteralID&gt; literals;
  literals.reserve(10000);</span>

<span style = "background-color:#dfd">  while ((input_file &gt;&gt; c) &amp;&amp; clauses_added &lt; nCls) {
    input_file.unget(); //extracted a nonspace character to determine if we have a clause, so put it back
    if ((c == '-') || isdigit(c)) {
      literals.clear();
      bool skip_clause = false;</span>
      int lit; // current literal
<span style = "background-color:#dfd">      while ((input_file &gt;&gt; lit) &amp;&amp; lit != 0) {
        bool duplicate_literal = false;
        for (auto i : literals) {
          if (i.toInt() == lit) {
            duplicate_literal = true;
            break;</span>
          }
<span style = "background-color:#dfd">          if (i.toInt() == -lit) {</span>
<span style = "background-color:#fdd">            skip_clause = true;
            break;</span>
          }
<span style = "background-color:#dfd">        }
        if (!duplicate_literal) {
          literals.push_back(LiteralID(lit));</span>
        }
<span style = "background-color:#dfd">      }
      if (!skip_clause) {
        clauses_added++;
        add_clause(literals);</span>
      }
    }
<span style = "background-color:#dfd">    input_file.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
  }</span>

  // all done
<span style = "background-color:#dfd">  finalize(nVars, nCls);
  return true;
}</span>

} // sharpSAT namespace</pre>
	</body>
</html>